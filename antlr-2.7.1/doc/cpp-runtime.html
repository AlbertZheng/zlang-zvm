<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- tidied with tidy -cmiu -wrap 72 -->

<HTML>
  <HEAD>
    <TITLE>C++ Notes</TITLE>
<STYLE type="text/css">
 p.c7 {font-family: Arial; font-size: 80%}
 p.c6 {font-weight: bold}
 tt.c5 {font-style: italic}
 span.c4 {font-family: Courier New}
 small.c3 {font-family: Courier New}
 small.c2 {color: #000000; font-family: Arial}
 a.c1 {color: #000000; font-family: Arial}
</STYLE>
  </HEAD>

  <BODY bgcolor="#FFFFFF" text="#000000">
    <TABLE height="27670">
      <TR valign="top">
        <TD align="center" valign="top" width="120" height="27666">
          &nbsp; 

          <P><A href="http://www.jguru.com"><IMG src= 
          "j-guru-blue.jpg" width="70" height="80" alt=
          "j-guru-blue.jpg (8086 bytes)" border="0"></A></P>

          <P><A href="http://www.antlr.org" class="c1"> <SMALL>
          <STRONG> ANTLR</STRONG></SMALL></A></P>

          <P><A href="http://www.jguru.com"><SMALL class="c2">
          <STRONG> jGuru</STRONG></SMALL></A></P>
        </TD>

        <TD width="500" height="27666">
          <H1><A name="_notes">C++ Notes</A></H1>
          <HR>

          <P>The C++ runtime and generated grammars look very much
          the same as the java ones. There are some subtle
          differences though, but more on this later.</P>

          <H2><A name="_buildruntime">Building the runtime</A></H2>

          <P>The runtime files are located in the lib/cpp
          subdirectory of the ANTLR distribution. This release is
          the first to include preliminary automake/autoconf
          support. Building it is in general done by doing the
          following:</P>
<PRE>
./configure --prefix=/usr/local
make
</PRE>

          <P>Installing the runtime is done by typing</P>
<PRE>
make install
</PRE>
          This installs the runtime library libantlr.a in
          /usr/local/lib and the header files in
          /usr/local/include/antlr. 

          <H2><A name="_usingruntime">Using the runtime</A></H2>
          Generally you will compile the ANTLR generated files with
          something similar to:
<PRE>
c++ -c MyParser.cpp -I/usr/local/include
</PRE>
          Linking is done with something similar to:
<PRE>
c++ -o MyExec &lt;your .o files&gt; -L/usr/local/lib -lantlr
</PRE>

          <H2><A name="_generatingcpp">Getting ANTLR to generate
          C++</A></H2>

          <P>To get ANTLR to generate C++ code you have to add</P>
<PRE>
language="Cpp";
</PRE>
          to the global options section. After that things are
          pretty much the same as in java mode except that a all
          token and AST classes are wrapped by a reference counting
          class (this to make live easier). The reference counting
          class uses 
<PRE>
operator-&gt;
</PRE>
          to reference the object it is wrapping. As a result of
          this you use -&gt; in C++ mode in stead of the '.' of
          java. See the examples in examples/c++ for some
          illustrations. 

          <H2><A name="_changingasttype">Using Custom AST
          types</A></H2>
          In C++ mode it is also possible to override the AST type
          used by the code generated by ANTLR. To do this you have
          to do the following: 

          <UL>
            <LI>
              Define a custom AST class like the following:
<PRE>
#include &lt;antlr/CommonAST.hpp&gt;

typedef antlr::ASTRefCount&lt;My_AST&gt; RefMyAST;

class MyAST : public antlr::CommonAST {
public:
    MyAST( void ) : down(), right()
    {
    }
    ~MyAST( void )
    {
    }
    void initialize( antlr::RefToken t )
    {
        antlr::CommonAST::initialize(t);
        // more stuff....
        // ...
    }
   void initialize(int t,const ANTLR_USE_NAMESPACE(std)string&amp; txt)
    {
        setType(t);
        setText(txt);
    }
    void addChild( RefMy_AST c )
    {
        antlr::BaseAST::addChild( static_cast&lt;antlr::RefAST&gt;(c) );
    }
    static antlr::RefAST factory( void )
    {
        antlr::RefAST ret = static_cast&lt;antlr::RefAST&gt;(RefMyAST(new MyAST));
        return ret;
    }
private:
    RefMyAST down;      // are these really necessary...
    RefMyAST right;
};
</PRE>
            </LI>

            <LI>
              Tell ANTLR's C++ codegenerator to use your RefMyAST
              by including the following in the options section:
<PRE>
ASTLabelType = "RefMyAST";
</PRE>
				  After that you only need to tell the parser before every
				  invocation of a new instance that it should use the AST
				  factory defined in your class. This is done like this:
<PRE>
My_Parser parser(lexer);
parser.setASTNodeFactory( MyAST::factory );
</PRE>
              If you do not do this only CommonAST objects get created and
				  used as if they were MyAST's. (In future versions this might
				  be done automatically) Now all ANTLR generated code uses
				  RefMyAST/MyAST as type. As a result you can access extra
				  members and methods without typecasting.
            </LI>
          </UL>

			 <H2><A name="_heteroast">Using Heterogeneous AST types</A></H2>
			 <P>This is largely untested. Small examples seem to work.
          Functionality from duptree and the likes will not work, this may
			 be fixed in the next release, in general inspection of the trees
			 will work, transformations 90% sure not.. Basically follow the
			 java instructions and look at the generated code. If someone
			 would be willing to share some experiences?

          <H2><A name="_template">A template grammar file for
          C++</A></H2>
<PRE>
header "pre_include_hpp" {
    // gets inserted before antlr generated includes in the header file
}
header "post_include_hpp" {
    // gets inserted after antlr generated includes in the header file
	 // outside any generated namespace specifications
}

header "pre_include_cpp" {
    // gets inserted after the antlr generated includes in the cpp file
}

header "post_include_cpp" {
    // gets inserted after the antlr generated includes in the cpp file
}

header {
	// gets inserted after generated namespace specifications in the header
	// file. But outside the generated class.
}

options {
   language="Cpp";
    namespace="something";      // encapsulate code in this namespace
//  namespaceStd="std";         // cosmetic option to get rid of long defines
                                // in generated code
//  namespaceAntlr="antlr";     // cosmetic option to get rid of long defines
                                // in generated code
    genHashLines = true;        // generated #line's or turn it off.
}

{
   // global stuff in the cpp file
   ...
}
class MyParser extends Parser;
options {
   exportVocab=My;
}
{
   // additional methods and members
   ...
}
... rules ...

{
   // global stuff in the cpp file
   ...
}
class MyLexer extends Lexer;
options {
   exportVocab=My;
}
{
   // additional methods and members
   ...
}
... rules ...

{
   // global stuff in the cpp file
   ...
}
class MyTreeParser extends TreeParser;
options {
   exportVocab=My;
}
{
   // additional methods and members
   ...
}
... rules ...
</PRE>

          <P class="c7">Version: $Id: //depot/code/org.antlr/release/antlr-2.7.1/doc/cpp-runtime.html#3 $</P>
        </TD>
      </TR>
    </TABLE>
  </BODY>
</HTML>

